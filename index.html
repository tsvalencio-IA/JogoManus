<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR KINECT TRILOGY: ULTIMATE</title>
    
    <!-- TensorFlow.js Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Russo+One&display=swap');

        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            font-family: 'Russo One', sans-serif;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Camada de V√≠deo (Espelhada e levemente escura para contraste) */
        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            filter: brightness(0.6) contrast(1.2);
            z-index: 0;
        }

        /* Camada do Jogo */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none; /* Deixa cliques passarem, ativado via classe */
        }

        .interactive {
            pointer-events: auto !important;
        }

        .title-glitch {
            text-shadow: 2px 2px 0px #ff00ff, -2px -2px 0px #00ffff;
            animation: glitch 0.5s infinite alternate;
        }

        @keyframes glitch {
            0% { transform: skew(0deg); }
            20% { transform: skew(-2deg); }
            40% { transform: skew(2deg); }
            100% { transform: skew(0deg); }
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            box-shadow: 0 0 15px #00ffff;
            backdrop-filter: blur(5px);
        }

        .btn-arcade {
            background: linear-gradient(45deg, #ff0055, #ff00aa);
            border: 3px solid #fff;
            box-shadow: 0 5px 0 #990033;
            transition: transform 0.1s;
        }
        .btn-arcade:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #990033;
        }

        /* Efeito de Flash ao bater */
        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            z-index: 30;
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Feedback Visual de Dano/Erro -->
        <div id="damage-overlay"></div>

        <!-- Fonte de V√≠deo (Oculta) -->
        <video id="video-source" playsinline style="display:none;"></video>
        
        <!-- Webcam Renderizada (Fundo) -->
        <video id="webcam" autoplay muted playsinline></video>

        <!-- Canvas Principal -->
        <canvas id="game-canvas"></canvas>

        <!-- UI System -->
        <div id="ui-layer" class="flex flex-col items-center justify-center">
            
            <!-- LOADER -->
            <div id="screen-loading" class="absolute inset-0 bg-black flex flex-col items-center justify-center interactive z-50">
                <h1 class="text-4xl text-cyan-400 animate-pulse mb-4">INICIALIZANDO SISTEMA AR</h1>
                <div class="w-64 h-4 bg-gray-800 rounded border border-cyan-500 overflow-hidden">
                    <div id="loading-bar" class="h-full bg-cyan-400 w-0 transition-all duration-1000"></div>
                </div>
                <p class="text-gray-400 mt-4 text-sm">Carregando Neural Network (MoveNet)...</p>
                <p class="text-gray-600 text-xs mt-2">Permita o uso da c√¢mera quando solicitado.</p>
            </div>

            <!-- MENU PRINCIPAL -->
            <div id="screen-menu" class="hidden absolute inset-0 bg-black/80 flex-col items-center justify-center interactive z-40">
                <h1 class="text-6xl md:text-8xl text-white font-black title-glitch mb-12 text-center leading-tight">
                    MOTION<br><span class="text-cyan-400">ARCADE</span>
                </h1>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6 w-full max-w-5xl px-4">
                    <!-- Card Drive -->
                    <button onclick="GameSystem.start('drive')" class="btn-arcade p-6 rounded-xl group hover:scale-105 transition-all">
                        <div class="text-4xl mb-2">üèéÔ∏è</div>
                        <h2 class="text-2xl text-white font-bold">NEON DRIVE</h2>
                        <p class="text-white/80 text-sm mt-2">Segure o volante imagin√°rio.</p>
                        <div class="mt-4 bg-black/30 p-2 rounded text-xs text-left text-white font-mono">
                            OBJETIVO: Dirigir longe<br>
                            CONTROLE: √Çngulo dos bra√ßos<br>
                            FALHA: Sair da pista
                        </div>
                    </button>

                    <!-- Card Run -->
                    <button onclick="GameSystem.start('run')" class="btn-arcade p-6 rounded-xl group hover:scale-105 transition-all" style="background: linear-gradient(45deg, #00aa55, #00ff55); box-shadow: 0 5px 0 #006633;">
                        <div class="text-4xl mb-2">üèÉ</div>
                        <h2 class="text-2xl text-white font-bold">TURBO RUN</h2>
                        <p class="text-white/80 text-sm mt-2">Corra no lugar fisicamente.</p>
                        <div class="mt-4 bg-black/30 p-2 rounded text-xs text-left text-white font-mono">
                            OBJETIVO: Desviar obst√°culos<br>
                            CONTROLE: Ritmo corporal + Inclinar<br>
                            FALHA: Colis√£o frontal
                        </div>
                    </button>

                    <!-- Card Dance -->
                    <button onclick="GameSystem.start('dance')" class="btn-arcade p-6 rounded-xl group hover:scale-105 transition-all" style="background: linear-gradient(45deg, #5500aa, #aa00ff); box-shadow: 0 5px 0 #330066;">
                        <div class="text-4xl mb-2">üíÉ</div>
                        <h2 class="text-2xl text-white font-bold">JUST POSE</h2>
                        <p class="text-white/80 text-sm mt-2">Copie as poses e pegue orbes.</p>
                        <div class="mt-4 bg-black/30 p-2 rounded text-xs text-left text-white font-mono">
                            OBJETIVO: High Score<br>
                            CONTROLE: Corpo inteiro<br>
                            FALHA: Errar timing
                        </div>
                    </button>
                </div>
            </div>

            <!-- HUD (IN GAME) -->
            <div id="screen-hud" class="hidden absolute top-0 w-full p-4 flex justify-between items-start pointer-events-none">
                <div class="hud-panel p-4 rounded-lg">
                    <div class="text-xs text-cyan-300 uppercase tracking-widest">Score</div>
                    <div id="hud-score" class="text-4xl text-white font-mono">00000</div>
                </div>
                
                <div id="hud-message" class="absolute top-20 left-1/2 transform -translate-x-1/2 text-center">
                    <h2 class="text-3xl text-yellow-400 font-black stroke-black drop-shadow-lg animate-bounce">PREPARE-SE!</h2>
                </div>

                <div class="hud-panel p-2 rounded-lg">
                    <button onclick="GameSystem.stop()" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded interactive">
                        SAIR
                    </button>
                </div>
            </div>

            <!-- GAME OVER -->
            <div id="screen-gameover" class="hidden absolute inset-0 bg-red-900/90 flex flex-col items-center justify-center interactive z-50">
                <h1 class="text-6xl text-white font-black mb-4 title-glitch">GAME OVER</h1>
                <p class="text-2xl text-white mb-8">Score Final: <span id="final-score" class="text-yellow-300">0</span></p>
                <button onclick="GameSystem.showMenu()" class="btn-arcade py-4 px-12 rounded-full text-xl font-bold text-white">
                    VOLTAR AO MENU
                </button>
            </div>

        </div>
    </div>

    <script>
        /**
         * =========================================================================
         * ENGINE GR√ÅFICA & UTILIT√ÅRIOS (Sem imagens externas)
         * =========================================================================
         */
        const Gfx = {
            drawCar: (ctx, x, y, scale, angle) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(scale, scale);
                ctx.rotate(angle);
                
                // Sombra
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(-35, 10, 70, 40);

                // Corpo do Carro (Estilo Ferrari Testarossa Retro)
                ctx.fillStyle = '#ff0033'; // Vermelho
                ctx.beginPath();
                ctx.moveTo(-30, 0);
                ctx.lineTo(30, 0);
                ctx.lineTo(35, 20); // Traseira larga
                ctx.lineTo(-35, 20);
                ctx.fill();

                // Teto
                ctx.fillStyle = '#990000';
                ctx.fillRect(-20, -15, 40, 15);

                // Luzes Traseiras (Neon)
                ctx.fillStyle = '#ff0000';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'red';
                ctx.fillRect(-32, 12, 20, 5);
                ctx.fillRect(12, 12, 20, 5);
                
                // Placa
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-8, 12, 16, 6);

                ctx.restore();
            },

            drawRunner: (ctx, x, y, scale, frame) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(scale, scale);

                // Stickman Sci-fi
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#00ff00';

                const legOffset = Math.sin(frame * 0.5) * 10;
                
                // Pernas
                ctx.beginPath();
                ctx.moveTo(0, 0); // Quadril
                ctx.lineTo(-10, 20 + legOffset); // Joelho Esq
                ctx.lineTo(-10, 40 + legOffset); // P√© Esq
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, 0); // Quadril
                ctx.lineTo(10, 20 - legOffset); // Joelho Dir
                ctx.lineTo(10, 40 - legOffset); // P√© Dir
                ctx.stroke();

                // Tronco
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -30);
                ctx.stroke();

                // Bra√ßos
                ctx.beginPath();
                ctx.moveTo(0, -25);
                ctx.lineTo(-15, -10 - legOffset);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, -25);
                ctx.lineTo(15, -10 + legOffset);
                ctx.stroke();

                // Cabe√ßa
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, -40, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            },

            drawObstacle: (ctx, x, y, scale, type) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(scale, scale);
                
                // Caixa de Perigo
                ctx.fillStyle = '#333';
                ctx.strokeStyle = '#ffcc00';
                ctx.lineWidth = 2;
                ctx.fillRect(-20, -40, 40, 40);
                ctx.strokeRect(-20, -40, 40, 40);
                
                // X no meio
                ctx.beginPath();
                ctx.moveTo(-20, -40); ctx.lineTo(20, 0);
                ctx.moveTo(20, -40); ctx.lineTo(-20, 0);
                ctx.stroke();

                ctx.restore();
            }
        };

        /**
         * =========================================================================
         * SISTEMA DE MOTION CAPTURE (TensorFlow MoveNet)
         * =========================================================================
         */
        class MotionEngine {
            constructor() {
                this.detector = null;
                this.video = document.getElementById('video-source');
                this.webcamDisplay = document.getElementById('webcam');
                this.ready = false;
                this.currentPose = null;
            }

            async init() {
                const updateBar = (pct) => document.getElementById('loading-bar').style.width = `${pct}%`;
                
                updateBar(20);
                await tf.setBackend('webgl');
                updateBar(50);
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 640, height: 480 },
                    audio: false
                });
                this.video.srcObject = stream;
                this.webcamDisplay.srcObject = stream; // Feed visual para o user

                await new Promise(r => this.video.onloadedmetadata = r);
                this.video.play();
                updateBar(70);

                const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
                this.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
                updateBar(100);
                
                this.ready = true;
                this.loop();
            }

            async loop() {
                if (this.ready) {
                    try {
                        const poses = await this.detector.estimatePoses(this.video);
                        if (poses && poses.length > 0) {
                            this.currentPose = poses[0];
                        }
                    } catch (e) { console.error(e); }
                }
                requestAnimationFrame(() => this.loop());
            }

            // Helpers de Extra√ß√£o de Dados
            getData() {
                if (!this.currentPose) return null;
                const kp = this.currentPose.keypoints;
                const find = (name) => kp.find(k => k.name === name);
                
                const nose = find('nose');
                const lw = find('left_wrist');
                const rw = find('right_wrist');
                const ls = find('left_shoulder');
                const rs = find('right_shoulder');

                // Confian√ßa m√≠nima
                const minConf = 0.3;
                if (!nose || nose.score < minConf) return null;

                return {
                    nose: nose,
                    wrists: { left: lw, right: rw },
                    shoulders: { left: ls, right: rs },
                    // Normalizados (0 a 1 em rela√ß√£o ao v√≠deo)
                    raw: kp
                };
            }
        }

        /**
         * =========================================================================
         * JOGO 1: NEON DRIVE (L√≥gica de Perspectiva)
         * =========================================================================
         */
        class GameDrive {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.active = false;
                
                // Estado do Jogo
                this.score = 0;
                this.playerX = 0; // -1 a 1
                this.speed = 0;
                this.maxSpeed = 120;
                this.roadPos = 0;
                
                // F√≠sica da Curva
                this.curve = 0;
                this.trackSection = 0;
            }

            start() {
                this.active = true;
                this.score = 0;
                this.speed = 0;
                this.playerX = 0;
                this.setMsg("M√ÉOS COMO VOLANTE!");
            }

            setMsg(txt) {
                const el = document.getElementById('hud-message');
                el.innerHTML = `<h2 class="text-3xl text-yellow-400 font-black drop-shadow-md">${txt}</h2>`;
            }

            update(motion) {
                const w = this.canvas.width;
                const h = this.canvas.height;

                // 1. INPUT (Volante Virtual)
                let steer = 0;
                if (motion && motion.wrists.left.score > 0.3 && motion.wrists.right.score > 0.3) {
                    // Diferen√ßa de altura Y entre os pulsos determina o √¢ngulo
                    const dy = motion.wrists.right.y - motion.wrists.left.y;
                    steer = dy * 0.02; // Sensibilidade
                    
                    // Acelera se detectar m√£os
                    if (this.speed < this.maxSpeed) this.speed += 2;
                } else {
                    // Desacelera
                    if (this.speed > 0) this.speed -= 1;
                    this.setMsg("CAD√ä SUAS M√ÉOS?");
                }

                // Aplicar dire√ß√£o
                this.playerX += steer * (this.speed / 100);

                // Gerar Curvas Procedurais
                this.roadPos += this.speed;
                if (this.roadPos > 2000) { // Nova se√ß√£o da pista
                    this.trackSection = (Math.random() - 0.5) * 2; // Nova curva aleat√≥ria
                    this.roadPos = 0;
                }
                // Lerp na curva atual
                this.curve += (this.trackSection - this.curve) * 0.01;

                // Mover Player com a curva (for√ßa centr√≠fuga)
                this.playerX -= this.curve * (this.speed / 2000);

                // Colis√£o (Sair da estrada)
                if (Math.abs(this.playerX) > 1.2) {
                    this.speed *= 0.8; // Perde velocidade na grama
                    document.getElementById('damage-overlay').style.opacity = 0.5;
                    setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 100);
                    this.setMsg("CUIDADO!!");
                }

                // Pontua√ß√£o
                this.score += Math.floor(this.speed / 10);
                
                // Draw
                this.draw(w, h, steer);
                
                return this.score;
            }

            draw(w, h, steer) {
                this.ctx.clearRect(0,0,w,h);

                const HorizonY = h * 0.4;
                const CenterX = w / 2;

                // C√âU E CH√ÉO
                const gradSky = this.ctx.createLinearGradient(0,0,0,HorizonY);
                gradSky.addColorStop(0, '#000033');
                gradSky.addColorStop(1, '#ff0055');
                this.ctx.fillStyle = gradSky;
                this.ctx.fillRect(0,0,w,HorizonY);

                this.ctx.fillStyle = '#111'; // Ch√£o
                this.ctx.fillRect(0, HorizonY, w, h - HorizonY);

                // ESTRADA (Trap√©zio)
                this.ctx.fillStyle = '#333';
                this.ctx.beginPath();
                // Topo da estrada (no horizonte) muda com a curva
                const roadTopX = CenterX + (this.curve * 300); 
                const roadTopW = 20;
                
                const roadBotX = CenterX;
                const roadBotW = w * 1.5; // Muito larga embaixo

                this.ctx.moveTo(roadTopX - roadTopW, HorizonY);
                this.ctx.lineTo(roadTopX + roadTopW, HorizonY);
                this.ctx.lineTo(roadBotX + roadBotW, h);
                this.ctx.lineTo(roadBotX - roadBotW, h);
                this.ctx.fill();

                // LINHAS DA PISTA (Movimento)
                this.ctx.strokeStyle = '#ffcc00';
                this.ctx.lineWidth = 10;
                const lineOffset = (Date.now() * (this.speed/20)) % 100;
                
                this.ctx.beginPath();
                this.ctx.moveTo(roadTopX, HorizonY);
                // Curva de B√©zier simples para a linha central
                this.ctx.quadraticCurveTo(
                    CenterX + (this.curve * 100), (HorizonY + h)/2, 
                    CenterX - (this.playerX * w * 0.5), h + lineOffset // Engana o olho movendo a base
                );
                this.ctx.stroke();

                // DESENHAR VOLANTE HUD
                this.ctx.strokeStyle = 'cyan';
                this.ctx.lineWidth = 5;
                this.ctx.beginPath();
                this.ctx.arc(CenterX, h - 100, 60, 0, Math.PI*2);
                this.ctx.stroke();
                // Indicador de rota√ß√£o
                this.ctx.save();
                this.ctx.translate(CenterX, h - 100);
                this.ctx.rotate(steer * 2);
                this.ctx.fillStyle = 'cyan';
                this.ctx.fillRect(-50, -5, 100, 10);
                this.ctx.restore();

                // CARRO
                const carX = CenterX + (this.playerX * 200);
                // Clamp visual
                const renderX = Math.max(100, Math.min(w-100, carX)); 
                Gfx.drawCar(this.ctx, CenterX, h - 80, 1.5, steer * 0.5);
            }
        }

        /**
         * =========================================================================
         * JOGO 2: TURBO RUN (L√≥gica de Pulo/Corrida)
         * =========================================================================
         */
        class GameRun {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.active = false;
                
                this.playerY = 0; // Posi√ß√£o vertical do nariz anterior
                this.runSpeed = 0;
                this.lane = 0; // -1 (Esq), 0 (Meio), 1 (Dir)
                this.obstacles = [];
                this.distance = 0;
                this.score = 0;
                this.frameCount = 0;
            }

            start() {
                this.active = true;
                this.score = 0;
                this.obstacles = [];
                this.distance = 0;
                this.runSpeed = 0;
                this.setMsg("CORRA NO LUGAR!");
            }

            setMsg(txt) {
                document.getElementById('hud-message').innerHTML = `<h2 class="text-3xl text-green-400 font-black drop-shadow-md">${txt}</h2>`;
            }

            update(motion) {
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // 1. INPUT (Corrida Estacion√°ria)
                if (motion) {
                    const noseY = motion.nose.y;
                    const delta = Math.abs(noseY - this.playerY);
                    
                    // Se o nariz mexe muito verticalmente = correndo
                    if (delta > 2) {
                        this.runSpeed += delta * 0.5;
                    }
                    this.playerY = noseY;

                    // Detectar Inclina√ß√£o para mudar de pista
                    const midX = (motion.shoulders.left.x + motion.shoulders.right.x) / 2;
                    const centerThreshold = this.canvas.width; // Mapear coord do video para canvas √© complexo, usando %
                    // Simplifica√ß√£o: Se nariz est√° na esquerda/direita do frame de v√≠deo
                    if (motion.nose.x < 200) this.lane = -1;
                    else if (motion.nose.x > 440) this.lane = 1;
                    else this.lane = 0;
                }

                // Atrito
                this.runSpeed *= 0.90;
                if (this.runSpeed < 1) this.runSpeed = 0;
                if (this.runSpeed > 50) this.runSpeed = 50;

                this.distance += this.runSpeed;
                this.score = Math.floor(this.distance / 10);

                // 2. OBST√ÅCULOS
                this.frameCount++;
                if (this.frameCount % 60 === 0 && this.runSpeed > 10) {
                    // Spawn obst√°culo
                    const lane = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
                    this.obstacles.push({ lane: lane, z: 1000 }); // Z come√ßa longe
                }

                // Mover obst√°culos
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    let obs = this.obstacles[i];
                    obs.z -= this.runSpeed; // Aproxima baseado na velocidade

                    // Colis√£o
                    if (obs.z < 50 && obs.z > -50) {
                        if (this.lane === obs.lane) {
                            // Bateu!
                            this.runSpeed = 0;
                            document.getElementById('damage-overlay').style.opacity = 0.8;
                            setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 200);
                            this.score -= 100;
                            this.obstacles.splice(i, 1);
                            continue;
                        }
                    }
                    // Remove se passou
                    if (obs.z < -100) {
                        this.obstacles.splice(i, 1);
                    }
                }

                if (this.runSpeed < 5) this.setMsg("CORRA MAIS R√ÅPIDO!");
                else this.setMsg("");

                this.draw(w, h);
                return this.score;
            }

            draw(w, h) {
                this.ctx.clearRect(0,0,w,h);
                const cx = w/2;
                const cy = h/2;

                // Fundo Matrix
                this.ctx.fillStyle = '#002200';
                this.ctx.fillRect(0,0,w,h);

                // Desenhar Pistas
                this.ctx.strokeStyle = '#005500';
                this.ctx.lineWidth = 2;
                // Linhas de perspectiva
                this.ctx.beginPath(); this.ctx.moveTo(cx - 20, cy); this.ctx.lineTo(0, h); this.ctx.stroke();
                this.ctx.beginPath(); this.ctx.moveTo(cx + 20, cy); this.ctx.lineTo(w, h); this.ctx.stroke();
                
                // Obst√°culos
                this.obstacles.forEach(obs => {
                    // Proje√ß√£o simples 3D -> 2D
                    const scale = 1000 / (obs.z + 100); 
                    const x = cx + (obs.lane * 200 * scale);
                    const y = cy + (100 * scale);
                    
                    if (scale > 0) Gfx.drawObstacle(this.ctx, x, y, scale * 2, 0);
                });

                // Jogador (Fixo no centro inferior, anima√ß√£o baseada na velocidade)
                const frame = Date.now() / (200 - this.runSpeed * 3);
                // A posi√ß√£o X do jogador muda suavemente visualmente
                const playerRenderX = cx + (this.lane * 100);
                Gfx.drawRunner(this.ctx, playerRenderX, h - 100, 2, this.runSpeed > 1 ? frame : 0);
            }
        }

        /**
         * =========================================================================
         * JOGO 3: JUST POSE (Espelho e Alvos)
         * =========================================================================
         */
        class GameDance {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.active = false;
                this.score = 0;
                this.targets = [];
                this.lastSpawn = 0;
            }

            start() {
                this.active = true;
                this.score = 0;
                this.targets = [];
                this.setMsg("ACERTE AS BOLHAS!");
            }

            setMsg(txt) {
                document.getElementById('hud-message').innerHTML = `<h2 class="text-3xl text-purple-400 font-black drop-shadow-md">${txt}</h2>`;
            }

            update(motion) {
                const w = this.canvas.width;
                const h = this.canvas.height;
                const now = Date.now();

                // 1. Spawnar Alvos R√≠tmicos
                if (now - this.lastSpawn > 1500) { // A cada 1.5s
                    this.targets.push({
                        x: Math.random() * (w - 100) + 50,
                        y: Math.random() * (h - 200) + 50,
                        r: 60, // Raio inicial
                        birth: now,
                        hit: false
                    });
                    this.lastSpawn = now;
                }

                // 2. Detectar Colis√£o (M√£o -> Alvo)
                if (motion) {
                    const hands = [motion.wrists.left, motion.wrists.right];
                    
                    this.targets.forEach(t => {
                        if (t.hit) return;
                        
                        hands.forEach(hand => {
                            if (hand.score > 0.3) {
                                // Mapear coordenadas do v√≠deo (640x480) para canvas
                                // Nota: Como v√≠deo est√° espelhado e object-fit cover, precisamos de aprox.
                                const hx = (1 - (hand.x / 640)) * w; // Inverter X pelo espelho
                                const hy = (hand.y / 480) * h;

                                const dist = Math.hypot(hx - t.x, hy - t.y);
                                if (dist < t.r) {
                                    t.hit = true;
                                    this.score += 500;
                                    // Efeito visual
                                    this.createExplosion(t.x, t.y);
                                }
                            }
                        });
                    });
                }

                // Limpar alvos velhos
                this.targets = this.targets.filter(t => (now - t.birth) < 2000 && !t.hit);

                this.draw(w, h, motion);
                return this.score;
            }

            createExplosion(x, y) {
                // Simplificado: flash na tela
                const el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                el.style.width = '100px';
                el.style.height = '100px';
                el.style.background = 'radial-gradient(circle, #fff, transparent)';
                el.style.transform = 'translate(-50%, -50%)';
                el.style.pointerEvents = 'none';
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 200);
            }

            draw(w, h, motion) {
                this.ctx.clearRect(0,0,w,h);
                
                // Desenhar Esqueleto do Jogador (Augmented Reality)
                if (motion) {
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    this.ctx.lineWidth = 5;
                    const drawLine = (p1, p2) => {
                        if(p1.score > 0.3 && p2.score > 0.3) {
                            const x1 = (1 - p1.x/640)*w; const y1 = (p1.y/480)*h;
                            const x2 = (1 - p2.x/640)*w; const y2 = (p2.y/480)*h;
                            this.ctx.beginPath(); this.ctx.moveTo(x1, y1); this.ctx.lineTo(x2, y2); this.ctx.stroke();
                        }
                    };
                    const kp = motion.raw;
                    // Bra√ßos e Ombros
                    drawLine(motion.wrists.left, kp[7]); // Wrist -> Elbow
                    drawLine(kp[7], motion.shoulders.left); // Elbow -> Shoulder
                    drawLine(motion.shoulders.left, motion.shoulders.right);
                    drawLine(motion.shoulders.right, kp[8]);
                    drawLine(kp[8], motion.wrists.right);
                }

                // Desenhar Alvos
                this.targets.forEach(t => {
                    const life = (Date.now() - t.birth) / 2000;
                    const radius = t.r * (1 - life); // Encolhe com o tempo
                    
                    this.ctx.beginPath();
                    this.ctx.arc(t.x, t.y, radius, 0, Math.PI*2);
                    this.ctx.fillStyle = `rgba(255, 0, 255, ${1-life})`;
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.stroke();
                });
            }
        }

        /**
         * =========================================================================
         * GESTOR DO SISTEMA
         * =========================================================================
         */
        const GameSystem = {
            motion: new MotionEngine(),
            canvas: document.getElementById('game-canvas'),
            activeGame: null,
            loopId: null,

            init: async () => {
                // Ajustar Canvas
                const resize = () => {
                    GameSystem.canvas.width = window.innerWidth;
                    GameSystem.canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resize);
                resize();

                // Iniciar Motion
                await GameSystem.motion.init();
                
                // Mostrar Menu
                document.getElementById('screen-loading').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
            },

            start: (gameType) => {
                // UI Transitions
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('flex');
                document.getElementById('screen-hud').classList.remove('hidden');
                document.getElementById('screen-gameover').classList.add('hidden');

                // Instanciar Jogo
                if (gameType === 'drive') GameSystem.activeGame = new GameDrive(GameSystem.canvas);
                if (gameType === 'run') GameSystem.activeGame = new GameRun(GameSystem.canvas);
                if (gameType === 'dance') GameSystem.activeGame = new GameDance(GameSystem.canvas);

                GameSystem.activeGame.start();
                GameSystem.loop();
            },

            stop: () => {
                cancelAnimationFrame(GameSystem.loopId);
                GameSystem.activeGame = null;
                GameSystem.showMenu();
            },

            gameOver: (finalScore) => {
                cancelAnimationFrame(GameSystem.loopId);
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-gameover').classList.remove('hidden');
                document.getElementById('screen-gameover').classList.add('flex');
                document.getElementById('final-score').innerText = finalScore;
            },

            showMenu: () => {
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-gameover').classList.add('hidden');
                document.getElementById('screen-menu').classList.remove('hidden');
                document.getElementById('screen-menu').classList.add('flex');
                // Limpar Canvas
                const ctx = GameSystem.canvas.getContext('2d');
                ctx.clearRect(0,0, GameSystem.canvas.width, GameSystem.canvas.height);
            },

            loop: () => {
                if (!GameSystem.activeGame) return;

                const poseData = GameSystem.motion.getData();
                const currentScore = GameSystem.activeGame.update(poseData);
                
                document.getElementById('hud-score').innerText = currentScore.toString().padStart(5, '0');

                GameSystem.loopId = requestAnimationFrame(GameSystem.loop);
            }
        };

        // Start
        window.onload = () => GameSystem.init();

    </script>
</body>
</html>
