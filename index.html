<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>thIAguinho Wii: ORIGINAL FIXED</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&display=swap');

        body {
            background-color: #000;
            margin: 0; overflow: hidden;
            font-family: 'Russo One', sans-serif;
            touch-action: none;
            user-select: none;
        }

        #game-container { position: relative; width: 100vw; height: 100vh; background: #000; }

        /* V√çDEO (Vis√≠vel mas escurecido para contraste do jogo) */
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Espelho */
            opacity: 0.4; 
            z-index: 0;
        }
        #video-source { display: none; }

        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        /* UI */
        .layer {
            position: absolute; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 50;
        }
        .hidden { display: none !important; }
        .interactive { pointer-events: auto !important; }

        /* Bot√µes Estilo Original */
        .btn-main {
            background: linear-gradient(to bottom, #00ffcc, #009977);
            border: 3px solid #fff;
            color: #003322;
            text-transform: uppercase;
            box-shadow: 0 0 15px #00ffcc;
            transition: transform 0.1s;
        }
        .btn-main:active { transform: scale(0.95); }

        .card-menu {
            background: rgba(0,0,0,0.8);
            border: 2px solid #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
            transition: all 0.2s;
        }
        .card-menu:hover { border-color: #00ffcc; transform: scale(1.05); }

        /* HUD */
        .hud-box {
            background: rgba(0,0,0,0.8);
            border: 2px solid #fff;
            padding: 10px 20px;
            border-radius: 8px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <video id="video-source" playsinline></video>
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="game-canvas"></canvas>

    <div id="screen-boot" class="layer bg-black interactive">
        <h1 class="text-5xl md:text-7xl text-white mb-2 text-center" style="text-shadow: 0 0 20px #00ffcc;">
            thIAguinho<br><span class="text-cyan-400">Wii</span>
        </h1>
        <p class="text-gray-400 font-mono text-sm mb-12">PRECISION EDITION</p>
        
        <button onclick="Core.boot()" class="btn-main px-12 py-6 rounded-full text-2xl font-bold animate-pulse">
            INICIAR JOGO
        </button>
        <div id="boot-status" class="mt-8 text-cyan-500 font-mono text-xs"></div>
    </div>

    <div id="screen-loading" class="layer bg-black/95 hidden">
        <div class="w-16 h-16 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <h2 class="text-white text-xl">CARREGANDO SISTEMA...</h2>
    </div>

    <div id="screen-menu" class="layer bg-black/90 hidden interactive overflow-y-auto">
        <h2 class="text-4xl text-white mb-8 text-center border-b-4 border-cyan-500 pb-2">SELECIONE</h2>
        
        <div class="grid gap-6 w-full max-w-sm px-6 pb-20">
            <button onclick="Core.launch('drive')" class="card-menu p-6 rounded-xl flex items-center gap-4 group cursor-pointer">
                <span class="text-5xl">üèéÔ∏è</span>
                <div class="text-left">
                    <h3 class="text-2xl text-white font-bold">CORRIDA</h3>
                    <p class="text-xs text-gray-400">M√£os = Volante (1:1)</p>
                </div>
            </button>

            <button onclick="Core.launch('run')" class="card-menu p-6 rounded-xl flex items-center gap-4 group cursor-pointer">
                <span class="text-5xl">üèÉ</span>
                <div class="text-left">
                    <h3 class="text-2xl text-white font-bold">RUA</h3>
                    <p class="text-xs text-gray-400">Corra e Desvie (Corrigido)</p>
                </div>
            </button>

            <button onclick="Core.launch('fight')" class="card-menu p-6 rounded-xl flex items-center gap-4 group cursor-pointer">
                <span class="text-5xl">ü•ä</span>
                <div class="text-left">
                    <h3 class="text-2xl text-white font-bold">BOXE</h3>
                    <p class="text-xs text-gray-400">Esqueleto Completo</p>
                </div>
            </button>
        </div>
    </div>

    <div id="screen-hud" class="layer hidden justify-between p-4 pointer-events-none !items-start">
        <div class="w-full flex justify-between">
            <div class="hud-box">
                <div class="text-[10px] text-cyan-400 font-bold uppercase">SCORE</div>
                <div id="hud-score" class="text-3xl text-white font-mono leading-none">0000</div>
            </div>
            <button onclick="Core.quit()" class="interactive bg-red-600 hover:bg-red-500 text-white w-12 h-12 rounded-full font-bold border-2 border-white text-xl">X</button>
        </div>

        <div id="game-msg" class="absolute top-1/3 w-full text-center text-4xl text-yellow-400 font-black drop-shadow-md"></div>

        <div id="ui-wheel" class="absolute bottom-20 left-1/2 -translate-x-1/2 opacity-0 transition-opacity">
            <div class="w-24 h-24 rounded-full border-4 border-cyan-500 flex items-center justify-center bg-black/50">
                <div id="wheel-bar" class="w-full h-2 bg-red-500 rounded"></div>
            </div>
        </div>

        <div class="interactive absolute bottom-6 right-6 bg-black/80 p-3 rounded-lg border border-white/20">
            <label class="text-[10px] text-white block text-center mb-1">SENSIBILIDADE</label>
            <input type="range" min="0.5" max="3.0" step="0.5" value="1.0" class="w-24 accent-cyan-400" oninput="Core.setSens(this.value)">
        </div>
    </div>

    <div id="screen-over" class="layer bg-red-900/95 hidden interactive z-50">
        <h1 class="text-6xl text-white font-black mb-4">GAME OVER</h1>
        <div class="text-7xl text-yellow-400 font-mono font-bold mb-8" id="final-score">0</div>
        <button onclick="Core.menu()" class="btn-main px-10 py-4 rounded-full text-xl font-bold">VOLTAR</button>
    </div>
</div>

<script>
    /**
     * =================================================================
     * üîä AUDIO (Sintetizador Puro - Mantido pois estava bom)
     * =================================================================
     */
    const Sfx = {
        ctx: null,
        init: () => { window.AudioContext = window.AudioContext || window.webkitAudioContext; Sfx.ctx = new AudioContext(); },
        play: (freq, type, dur, vol=0.1) => {
            if(!Sfx.ctx) return;
            const o = Sfx.ctx.createOscillator(); const g = Sfx.ctx.createGain();
            o.type=type; o.frequency.value=freq;
            g.gain.setValueAtTime(vol, Sfx.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, Sfx.ctx.currentTime+dur);
            o.connect(g); g.connect(Sfx.ctx.destination);
            o.start(); o.stop(Sfx.ctx.currentTime+dur);
        },
        coin: () => { Sfx.play(1200,'square',0.1); setTimeout(()=>Sfx.play(1600,'square',0.1), 80); },
        hit: () => { Sfx.play(100,'sawtooth',0.2); },
        crash: () => { Sfx.play(80,'sawtooth',0.5, 0.3); },
        start: () => { Sfx.play(440,'triangle',0.1); setTimeout(()=>Sfx.play(880,'triangle',0.3), 100); }
    };

    /**
     * =================================================================
     * üé® GRAPHICS (Visual Original + Esqueleto Completo)
     * =================================================================
     */
    const Gfx = {
        // ESQUELETO PERFEITO
        drawSkeleton: (ctx, pose, w, h) => {
            if(!pose) return;
            const kp = pose.keypoints;
            const find = n => kp.find(k=>k.name===n);
            const mapX = x => w - (x/640 * w); // Espelho X
            const mapY = y => y/480 * h;

            ctx.lineCap='round'; ctx.lineJoin='round';
            ctx.strokeStyle='#00ffff'; ctx.lineWidth=6;

            // Pontos principais
            const nose = find('nose');
            const ls = find('left_shoulder'); const rs = find('right_shoulder');
            const le = find('left_elbow'); const re = find('right_elbow');
            const lw = find('left_wrist'); const rw = find('right_wrist');
            const lh = find('left_hip'); const rh = find('right_hip');

            // Fun√ß√£o para desenhar linha entre dois pontos
            const drawBone = (p1, p2) => {
                if(p1 && p2 && p1.score>0.3 && p2.score>0.3) {
                    ctx.beginPath();
                    ctx.moveTo(mapX(p1.x), mapY(p1.y));
                    ctx.lineTo(mapX(p2.x), mapY(p2.y));
                    ctx.stroke();
                }
            };

            // 1. Bra√ßos
            drawBone(ls, le); drawBone(le, lw);
            drawBone(rs, re); drawBone(re, rw);
            // 2. Ombros
            drawBone(ls, rs);
            // 3. Tronco (Se hips vis√≠veis, usa. Sen√£o, estima coluna reta para baixo)
            if(lh && rh && lh.score>0.2) {
                drawBone(ls, lh); drawBone(rs, rh); drawBone(lh, rh);
            } else if(ls && rs) {
                // Estima tronco se a c√¢mera cortar a cintura
                const midShoulderX = (ls.x + rs.x)/2;
                const midShoulderY = (ls.y + rs.y)/2;
                ctx.beginPath();
                ctx.moveTo(mapX(midShoulderX), mapY(midShoulderY));
                ctx.lineTo(mapX(midShoulderX), mapY(midShoulderY)+150);
                ctx.stroke();
            }

            // Cabe√ßa
            if(nose && nose.score>0.3) {
                ctx.fillStyle='#fff';
                ctx.beginPath(); ctx.arc(mapX(nose.x), mapY(nose.y-20), 25, 0, Math.PI*2); ctx.fill();
            }
            // Luvas
            if(lw && lw.score>0.3) { ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(mapX(lw.x), mapY(lw.y), 30, 0, Math.PI*2); ctx.fill(); }
            if(rw && rw.score>0.3) { ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(mapX(rw.x), mapY(rw.y), 30, 0, Math.PI*2); ctx.fill(); }
        },

        drawRoad: (ctx, w, h, pos, curve) => {
            const cx = w/2;
            const horizon = h * 0.4;

            // Fundo original (Preto/Escuro)
            ctx.fillStyle = '#050505'; 
            ctx.fillRect(0,0,w,h);
            
            // C√©u simples (apenas uma linha de horizonte)
            ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, horizon); ctx.lineTo(w, horizon); ctx.stroke();

            // Pista Geom√©trica (Trap√©zio Simples e Limpo)
            // Sem mode 7 confuso, apenas perspectiva vetorial n√≠tida
            ctx.fillStyle = '#333';
            ctx.beginPath();
            const topW = 20; // Largura no horizonte
            const botW = w * 1.5; // Largura na base
            
            const curveOffset = curve * 200;
            
            ctx.moveTo(cx + curveOffset - topW, horizon);
            ctx.lineTo(cx + curveOffset + topW, horizon);
            ctx.lineTo(cx + botW, h);
            ctx.lineTo(cx - botW, h);
            ctx.fill();

            // Linha Central
            ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = 6;
            ctx.setLineDash([40, 40]); ctx.lineDashOffset = -pos;
            ctx.beginPath();
            ctx.moveTo(cx + curveOffset, horizon);
            ctx.quadraticCurveTo(cx + (curveOffset*0.5), h*0.7, cx, h);
            ctx.stroke();
            ctx.setLineDash([]);
        },

        drawCar: (ctx, x, y, steer) => {
            ctx.save(); ctx.translate(x, y); 
            ctx.rotate(steer); 
            ctx.scale(2, 2);
            // Sombra
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(-25, -10, 50, 40);
            // Carro (Ret√¢ngulo Arredondado Simples - Estilo Original)
            ctx.fillStyle = '#ff0033';
            ctx.beginPath(); ctx.roundRect(-20, -20, 40, 40, 5); ctx.fill();
            // Para-brisas
            ctx.fillStyle = '#111'; ctx.fillRect(-15, -10, 30, 10);
            // Far√≥is
            ctx.fillStyle = '#ffcc00'; ctx.fillRect(-18, -18, 8, 5); ctx.fillRect(10, -18, 8, 5);
            ctx.restore();
        },

        drawRunner: (ctx, x, y, frame) => {
            ctx.save(); ctx.translate(x, y); ctx.scale(3, 3);
            ctx.strokeStyle='#00ff00'; ctx.lineWidth=3; ctx.lineCap='round';
            const s = Math.sin(frame*0.5)*10;
            // Tronco
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-15); ctx.stroke();
            // Pernas
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-8+s, 20); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(8-s, 20); ctx.stroke();
            // Bra√ßos
            ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(-10-s, -5); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(10+s, -5); ctx.stroke();
            // Cabe√ßa
            ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,-22,5,0,Math.PI*2); ctx.fill();
            ctx.restore();
        }
    };

    /**
     * =================================================================
     * üß† ENGINE (L√≥gica Central)
     * =================================================================
     */
    const Core = {
        video: null, canvas: null, ctx: null, detector: null,
        active: false, mode: null, sens: 1.0, loopId: null,

        boot: async () => {
            document.getElementById('boot-status').innerText = "Iniciando...";
            Sfx.init();

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} },
                    audio: false
                });
                Core.video = document.getElementById('video-source');
                Core.video.srcObject = stream;
                document.getElementById('webcam').srcObject = stream;
                await new Promise(r => Core.video.onloadedmetadata = r);
                Core.video.play(); document.getElementById('webcam').play();

                document.getElementById('screen-boot').classList.add('hidden');
                document.getElementById('screen-loading').classList.remove('hidden');

                await tf.setBackend('webgl');
                Core.detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.MoveNet,
                    { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
                );

                Core.canvas = document.getElementById('game-canvas');
                Core.ctx = Core.canvas.getContext('2d');
                
                document.getElementById('screen-loading').classList.add('hidden');
                Core.menu();
            } catch(e) { alert("Erro na c√¢mera: " + e.message); }
        },

        menu: () => {
            document.getElementById('screen-menu').classList.remove('hidden');
            document.getElementById('screen-hud').classList.add('hidden');
            document.getElementById('screen-over').classList.add('hidden');
        },

        launch: (m) => {
            Core.mode = m; Core.active = true;
            document.getElementById('screen-menu').classList.add('hidden');
            document.getElementById('screen-hud').classList.remove('hidden');
            
            // Toggle UI
            const wheel = document.getElementById('ui-wheel');
            wheel.style.opacity = (m==='drive') ? '1' : '0';

            if(m==='drive') Logic.Drive.init();
            if(m==='run') Logic.Run.init();
            if(m==='fight') Logic.Fight.init();
            
            Sfx.start();
            Core.loop();
        },

        quit: () => {
            Core.active = false; cancelAnimationFrame(Core.loopId); Core.menu();
        },

        gameOver: (score) => {
            Core.active = false; cancelAnimationFrame(Core.loopId);
            Sfx.crash();
            document.getElementById('final-score').innerText = score;
            document.getElementById('screen-hud').classList.add('hidden');
            document.getElementById('screen-over').classList.remove('hidden');
        },

        setSens: (v) => Core.sens = parseFloat(v),

        msg: (txt) => {
            const el = document.getElementById('game-msg');
            el.innerText = txt;
            setTimeout(()=>el.innerText='', 1500);
        },

        loop: async () => {
            if(!Core.active) return;
            if(Core.canvas.width !== window.innerWidth) {
                Core.canvas.width = window.innerWidth;
                Core.canvas.height = window.innerHeight;
            }
            const ctx = Core.ctx; const w = Core.canvas.width; const h = Core.canvas.height;

            let pose = null;
            try {
                const poses = await Core.detector.estimatePoses(Core.video, {flipHorizontal: false});
                if(poses.length>0) pose = poses[0];
            } catch(e){}

            let score = 0;
            if(Core.mode==='drive') score = Logic.Drive.update(ctx, w, h, pose);
            if(Core.mode==='run') score = Logic.Run.update(ctx, w, h, pose);
            if(Core.mode==='fight') score = Logic.Fight.update(ctx, w, h, pose);

            document.getElementById('hud-score').innerText = score;
            Core.loopId = requestAnimationFrame(Core.loop);
        }
    };

    /**
     * =================================================================
     * üß† L√ìGICA DO JOGO (CORRIGIDA)
     * =================================================================
     */
    const Logic = {
        
        // --- JOGO 1: CORRIDA (Volante Trigonom√©trico) ---
        Drive: {
            speed: 0, pos: 0, x: 0, steer: 0, curve: 0,
            init: () => { Logic.Drive.speed=0; Logic.Drive.pos=0; Logic.Drive.x=0; Core.msg("DIRIJA!"); },
            update: (ctx, w, h, pose) => {
                const d = Logic.Drive;
                const cx = w/2;

                // INPUT PRECISO (ATAN2)
                let targetAngle = 0;
                if(pose) {
                    const lw = pose.keypoints.find(k=>k.name==='left_wrist');
                    const rw = pose.keypoints.find(k=>k.name==='right_wrist');
                    if(lw && rw && lw.score>0.3 && rw.score>0.3) {
                        const dy = rw.y - lw.y;
                        const dx = rw.x - lw.x;
                        const rads = Math.atan2(dy, dx);
                        targetAngle = rads * 1.5 * Core.sens;
                        if(d.speed < 100) d.speed += 1;
                    } else {
                        d.speed *= 0.95;
                    }
                }
                d.steer += (targetAngle - d.steer) * 0.2; // Suaviza√ß√£o

                // UI Volante
                const bar = document.getElementById('wheel-bar');
                if(bar) bar.style.transform = `rotate(${d.steer * 57}deg)`;

                // F√≠sica
                d.pos += d.speed;
                d.curve = Math.sin(d.pos * 0.005) * 1.5;
                
                d.x += d.steer * (d.speed/500);
                d.x -= d.curve * (d.speed/1000);

                if(Math.abs(d.x) > 1.2) { d.speed *= 0.9; } // Colis√£o borda

                // Desenho
                Gfx.drawRoad(ctx, w, h, d.pos, d.curve);
                const carX = cx + (d.x * w * 0.25);
                Gfx.drawCar(ctx, carX, h-80, d.steer);

                return Math.floor(d.pos/100);
            }
        },

        // --- JOGO 2: RUA (Espelho Invertido) ---
        Run: {
            lane: 0, score: 0, frame: 0, obs: [],
            init: () => { Logic.Run.score=0; Logic.Run.obs=[]; Core.msg("CORRA!"); },
            update: (ctx, w, h, pose) => {
                const r = Logic.Run;
                const cx = w/2;
                r.frame++;

                // INPUT CORRIGIDO
                // Raw: 0(Esq) -> 640(Dir). Espelho: Inverte.
                if(pose) {
                    const nose = pose.keypoints.find(k=>k.name==='nose');
                    if(nose && nose.score > 0.4) {
                        if(nose.x < 240) r.lane = 1; // Minha Dir F√≠sica = Direita Tela
                        else if(nose.x > 400) r.lane = -1; // Minha Esq F√≠sica = Esquerda Tela
                        else r.lane = 0;
                    }
                }

                if(r.frame%50===0) r.obs.push({l: Math.floor(Math.random()*3)-1, z: 1000});

                ctx.clearRect(0,0,w,h);
                // Fundo Simples
                ctx.fillStyle = '#111'; ctx.fillRect(0,0,w,h);
                
                // Grid Ch√£o
                ctx.strokeStyle='#00ffcc'; ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(cx-150, h/2); ctx.lineTo(0,h); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx+150, h/2); ctx.lineTo(w,h); ctx.stroke();

                r.obs.forEach((o, i) => {
                    o.z -= 20; 
                    if(o.z < -100) { r.obs.splice(i,1); r.score+=10; Sfx.coin(); }
                    
                    const scale = 500/(o.z+100);
                    if(scale > 0) {
                        const ox = cx + (o.l * 200 * scale);
                        const oy = h/2 + (50 * scale);
                        const sz = 80 * scale;

                        ctx.fillStyle = '#ff3300';
                        ctx.fillRect(ox-sz/2, oy, sz, sz);

                        if(o.z < 50 && o.z > -50 && o.l === r.lane) {
                            Core.gameOver(r.score);
                        }
                    }
                });

                Gfx.drawRunner(ctx, cx + (r.lane*150), h-100, r.frame);
                return r.score;
            }
        },

        // --- JOGO 3: BOXE (Esqueleto Completo) ---
        Fight: {
            score: 0, targets: [], last: 0,
            init: () => { Logic.Fight.score=0; Logic.Fight.targets=[]; Core.msg("BOXE!"); },
            update: (ctx, w, h, pose) => {
                const f = Logic.Fight;
                const now = Date.now();
                ctx.clearRect(0,0,w,h);

                // 1. DESENHO OBRIGAT√ìRIO DO ESQUELETO
                Gfx.drawSkeleton(ctx, pose, w, h);

                // 2. INPUT
                let punches = [];
                if(pose) {
                    const mapX = x => w - (x/640 * w);
                    const mapY = y => y/480 * h;
                    const lw = pose.keypoints.find(k=>k.name==='left_wrist');
                    const rw = pose.keypoints.find(k=>k.name==='right_wrist');
                    if(lw && lw.score>0.3) punches.push({x: mapX(lw.x), y: mapY(lw.y)});
                    if(rw && rw.score>0.3) punches.push({x: mapX(rw.x), y: mapY(rw.y)});
                }

                if(now - f.last > 800) {
                    f.targets.push({x: Math.random()*(w-100)+50, y: Math.random()*(h/2)+50, r: 40, s: now});
                    f.last = now;
                }

                f.targets.forEach((t, i) => {
                    const age = (now - t.s)/1500;
                    if(age>1) { f.targets.splice(i,1); return; }

                    ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                    ctx.fillStyle=`rgba(255,255,0,${1-age})`; ctx.fill();
                    ctx.strokeStyle='#fff'; ctx.stroke();

                    punches.forEach(p => {
                        if(Math.hypot(p.x-t.x, p.y-t.y) < t.r + 30) {
                            f.targets.splice(i,1);
                            f.score += 100;
                            Sfx.hit();
                        }
                    });
                });

                return f.score;
            }
        }
    };
</script>
</body>
</html>
