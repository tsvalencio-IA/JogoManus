<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>thIAguinho Wii: DIAMOND EDITION</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Russo+One&display=swap');

        /* --- ENGINE CORE --- */
        body {
            background-color: #000;
            margin: 0; overflow: hidden;
            font-family: 'Russo One', sans-serif;
            touch-action: none; /* Bloqueia zoom no celular */
            user-select: none;
            -webkit-user-select: none;
        }

        #stage { position: relative; width: 100vw; height: 100vh; background: #000; }

        /* V√çDEO (Espelho M√°gico) */
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Espelha o v√≠deo visualmente */
            opacity: 0.3; /* Transpar√™ncia para o jogo brilhar */
            filter: grayscale(100%) contrast(1.2);
            z-index: 0;
        }
        #video-source { display: none; } /* Feed cru para a IA */

        /* CANVAS (Camada de Jogo) */
        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        /* UI (Interfaces) */
        .layer {
            position: absolute; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20; transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; display: none !important; }
        .interactive { pointer-events: auto !important; }

        /* ESTILO NINTENDO */
        .pixel-font { font-family: 'Press Start 2P', cursive; }
        
        .n-btn {
            background: linear-gradient(180deg, #00d2ff 0%, #3a7bd5 100%);
            border: 4px solid #fff;
            box-shadow: 0 6px 0 #005cbf, 0 10px 20px rgba(0,0,0,0.5);
            color: white;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .n-btn:active { transform: translateY(6px); box-shadow: 0 0 0 #005cbf; }

        .card {
            background: rgba(30,30,30,0.9);
            border: 2px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        .card:hover { border-color: #00ffff; background: rgba(0,255,255,0.1); transform: scale(1.02); }

        /* HUD */
        .hud-panel {
            background: rgba(0,0,0,0.8);
            border: 2px solid #fff;
            border-radius: 12px;
            padding: 8px 16px;
            box-shadow: 0 0 10px rgba(0,255,255,0.3);
        }
    </style>
</head>
<body>

<div id="stage">
    <video id="video-source" playsinline></video>
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="game-canvas"></canvas>

    <div id="screen-boot" class="layer bg-black interactive">
        <h1 class="text-4xl md:text-6xl text-white mb-4 text-center pixel-font text-cyan-400 leading-tight drop-shadow-lg">
            thIAguinho<br><span class="text-white text-3xl">Wii MOTION</span>
        </h1>
        <p class="text-gray-500 text-xs mb-12 font-mono">V 6.0 DIAMOND ‚Ä¢ PRECIS√ÉO ABSOLUTA</p>
        
        <button onclick="Engine.boot()" class="n-btn px-10 py-5 rounded-full text-xl font-bold uppercase tracking-widest animate-pulse">
            PRESS START
        </button>
        <div id="boot-log" class="mt-8 text-cyan-600 font-mono text-xs">Aguardando gesto do usu√°rio...</div>
    </div>

    <div id="screen-loading" class="layer bg-black/95 hidden">
        <div class="relative w-20 h-20 mb-6">
            <div class="absolute inset-0 border-4 border-cyan-500/30 rounded-full"></div>
            <div class="absolute inset-0 border-4 border-cyan-400 border-t-transparent rounded-full animate-spin"></div>
        </div>
        <div class="text-white pixel-font text-xs tracking-widest">CALIBRANDO IA...</div>
    </div>

    <div id="screen-menu" class="layer bg-black/85 hidden interactive overflow-y-auto">
        <h2 class="text-3xl text-white mb-10 pixel-font text-center drop-shadow-[0_0_10px_rgba(255,255,255,0.8)]">SELECT GAME</h2>
        
        <div class="grid gap-6 w-full max-w-sm px-6 pb-10">
            <button onclick="Engine.launch('kart')" class="card p-5 rounded-xl flex items-center gap-4 group text-left cursor-pointer">
                <div class="text-5xl group-hover:scale-110 transition-transform">üèéÔ∏è</div>
                <div>
                    <h3 class="text-lg text-white font-bold group-hover:text-red-400">PRECISION KART</h3>
                    <p class="text-[10px] text-gray-400 font-mono">Dire√ß√£o 1:1 Realista</p>
                </div>
            </button>

            <button onclick="Engine.launch('run')" class="card p-5 rounded-xl flex items-center gap-4 group text-left cursor-pointer">
                <div class="text-5xl group-hover:scale-110 transition-transform">üèÉ</div>
                <div>
                    <h3 class="text-lg text-white font-bold group-hover:text-green-400">STREET RUNNER</h3>
                    <p class="text-[10px] text-gray-400 font-mono">Dire√ß√£o Corrigida (Espelho)</p>
                </div>
            </button>

            <button onclick="Engine.launch('box')" class="card p-5 rounded-xl flex items-center gap-4 group text-left cursor-pointer">
                <div class="text-5xl group-hover:scale-110 transition-transform">ü•ä</div>
                <div>
                    <h3 class="text-lg text-white font-bold group-hover:text-purple-400">PRO BOXING</h3>
                    <p class="text-[10px] text-gray-400 font-mono">Esqueleto Completo AR</p>
                </div>
            </button>
        </div>
        
        <div class="fixed bottom-4 text-gray-500 text-[10px] font-mono w-full text-center">Desenvolvido com ü§ñ por thIAguinho Solu√ß√µes</div>
    </div>

    <div id="screen-hud" class="layer hidden justify-between p-4 pointer-events-none !items-start">
        <div class="w-full flex justify-between">
            <div class="hud-panel">
                <div class="text-[10px] text-cyan-400 font-bold tracking-wider">SCORE</div>
                <div id="score-val" class="text-3xl text-white font-mono leading-none">0000</div>
            </div>
            
            <button onclick="Engine.quit()" class="pointer-events-auto bg-red-600 hover:bg-red-500 text-white w-12 h-12 rounded-full font-bold border-2 border-white shadow-lg transition-transform hover:rotate-90">X</button>
        </div>

        <div id="wheel-ui" class="absolute bottom-20 left-1/2 -translate-x-1/2 opacity-0 transition-opacity duration-300">
            <div class="w-32 h-32 rounded-full border-8 border-gray-700 bg-black/50 relative shadow-2xl">
                <div id="wheel-indicator" class="w-full h-4 bg-red-600 absolute top-1/2 -translate-y-1/2 rounded-full shadow-[0_0_10px_red]"></div>
            </div>
        </div>

        <div id="msg-area" class="absolute top-1/3 w-full text-center"></div>

        <div id="hp-bar-container" class="absolute bottom-10 left-1/2 -translate-x-1/2 w-72 h-8 bg-gray-900 border-2 border-white rounded-full hidden overflow-hidden shadow-lg">
            <div id="hp-bar" class="w-full h-full bg-gradient-to-r from-green-500 to-green-300 transition-all duration-200"></div>
        </div>
    </div>

    <div id="screen-over" class="layer bg-red-900/95 hidden pointer-events-auto">
        <h1 class="text-5xl text-white mb-6 pixel-font drop-shadow-lg">GAME OVER</h1>
        <div class="bg-black/30 p-8 rounded-2xl border-2 border-red-400 mb-8 backdrop-blur">
            <div class="text-xs text-red-200 uppercase tracking-widest mb-2">Pontua√ß√£o Final</div>
            <div class="text-7xl text-yellow-400 font-mono font-bold" id="final-score">0</div>
        </div>
        <button onclick="Engine.menu()" class="n-btn px-10 py-4 rounded-full text-lg font-bold">VOLTAR AO MENU</button>
    </div>
</div>

<script>
    /**
     * ==========================================
     * üîä AUDIO (Sintetizador Puro)
     * ==========================================
     */
    const Sfx = {
        ctx: null,
        init: () => { window.AudioContext = window.AudioContext || window.webkitAudioContext; Sfx.ctx = new AudioContext(); },
        play: (freq, type, dur, vol=0.1) => {
            if(!Sfx.ctx) return;
            const o = Sfx.ctx.createOscillator(); const g = Sfx.ctx.createGain();
            o.type=type; o.frequency.value=freq;
            g.gain.setValueAtTime(vol, Sfx.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, Sfx.ctx.currentTime+dur);
            o.connect(g); g.connect(Sfx.ctx.destination);
            o.start(); o.stop(Sfx.ctx.currentTime+dur);
        },
        coin: () => { Sfx.play(1200, 'square', 0.1, 0.05); setTimeout(()=>Sfx.play(1600,'square',0.1, 0.05), 80); },
        hit: () => { Sfx.play(100, 'sawtooth', 0.1, 0.2); },
        jump: () => { Sfx.play(300, 'sine', 0.2, 0.1); },
        start: () => { Sfx.play(440, 'triangle', 0.1); setTimeout(()=>Sfx.play(880,'triangle',0.4), 100); }
    };

    /**
     * ==========================================
     * üé® GRAPHICS (Sprites & Esqueleto)
     * ==========================================
     */
    const Gfx = {
        // Fun√ß√£o para desenhar esqueleto COMPLETO (Boxe)
        drawFullSkeleton: (ctx, pose, w, h) => {
            if(!pose) return;
            const kp = pose.keypoints;
            const find = n => kp.find(k => k.name === n);
            
            // Mapeamento de Espelho: Inverte o X
            const mapX = x => w - (x / 640 * w);
            const mapY = y => y / 480 * h;

            const joints = [
                ['left_shoulder','right_shoulder'], // Ombros
                ['left_shoulder','left_elbow'], ['left_elbow','left_wrist'], // Bra√ßo Esq
                ['right_shoulder','right_elbow'], ['right_elbow','right_wrist'], // Bra√ßo Dir
                ['left_shoulder','left_hip'], ['right_shoulder','right_hip'], // Tronco (Estimado)
                ['left_hip','right_hip'] // Quadril (Estimado)
            ];

            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';

            // Desenhar Ossos
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)'; 
            ctx.lineWidth = 6;

            joints.forEach(pair => {
                const p1 = find(pair[0]);
                const p2 = find(pair[1]);
                
                // Se o TensorFlow n√£o achar o quadril, estimamos baseado no ombro
                let x1, y1, x2, y2;
                
                if(p1) { x1 = mapX(p1.x); y1 = mapY(p1.y); }
                if(p2) { x2 = mapX(p2.x); y2 = mapY(p2.y); }

                // Fallback para quadril se n√£o detectado (comum em webcam de rosto)
                if(pair[1].includes('hip') && (!p2 || p2.score < 0.2) && p1) {
                    x2 = x1; y2 = y1 + 150; // Estima tronco para baixo
                }

                if(x1 && x2) {
                    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                }
            });

            // Cabe√ßa
            const nose = find('nose');
            if(nose && nose.score > 0.3) {
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(mapX(nose.x), mapY(nose.y - 30), 20, 0, Math.PI*2); ctx.fill();
            }

            // Luvas nas m√£os
            ['left_wrist', 'right_wrist'].forEach(name => {
                const p = find(name);
                if(p && p.score > 0.3) {
                    ctx.fillStyle = 'red'; ctx.shadowColor = 'red';
                    ctx.beginPath(); ctx.arc(mapX(p.x), mapY(p.y), 25, 0, Math.PI*2); ctx.fill();
                }
            });
            
            ctx.shadowBlur = 0;
        },

        drawRoad: (ctx, w, h, pos, curve) => {
            const hor = h * 0.4;
            // C√©u
            let grad = ctx.createLinearGradient(0,0,0,hor);
            grad.addColorStop(0,'#000022'); grad.addColorStop(1,'#440022');
            ctx.fillStyle=grad; ctx.fillRect(0,0,w,hor);
            
            // Ch√£o
            ctx.fillStyle='#1a1a1a'; ctx.fillRect(0,hor,w,h-hor);

            const cx = w/2;
            for(let i=0; i<25; i++) {
                let z = i + (pos%1); 
                let scale = 1/z;
                let y = h - (scale * (h-hor) * 4);
                if(y < hor) continue;
                
                let rw = w * 2.0 * scale; 
                let curveX = Math.pow(i, 2) * curve * (w/200);

                // Asfalto
                ctx.fillStyle = (Math.floor(z + pos)%2===0) ? '#444' : '#555';
                ctx.fillRect(cx - rw/2 + curveX, y, rw, 15);
                
                // Bordas
                ctx.fillStyle = (Math.floor(z + pos)%2===0) ? '#e74c3c' : '#ecf0f1';
                let bw = rw * 0.15;
                ctx.fillRect(cx - rw/2 + curveX - bw, y, bw, 15);
                ctx.fillRect(cx + rw/2 + curveX, y, bw, 15);
            }
        },

        drawKart: (ctx, x, y, steer) => {
            ctx.save(); ctx.translate(x, y); 
            ctx.rotate(steer); // Rota√ß√£o real baseada no volante
            ctx.scale(2.5, 2.5);
            
            // Sombra
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.ellipse(0,5,25,10,0,0,Math.PI*2); ctx.fill();
            
            // Chassi
            ctx.fillStyle='#d32f2f'; 
            ctx.beginPath(); 
            ctx.moveTo(-20, 10); ctx.lineTo(-15, -10); // Traseira
            ctx.lineTo(15, -10); ctx.lineTo(20, 10); // Frente
            ctx.fill();

            // Spoiler
            ctx.fillStyle='#b71c1c'; ctx.fillRect(-22, 8, 44, 4);

            // Capacete
            ctx.fillStyle='#ffeb3b'; ctx.beginPath(); ctx.arc(0, -5, 7, 0, Math.PI*2); ctx.fill();
            
            ctx.restore();
        },

        drawRunner: (ctx, x, y, frame, jumping) => {
            ctx.save(); ctx.translate(x, y); ctx.scale(3, 3);
            ctx.strokeStyle='#00e676'; ctx.lineWidth=3; ctx.lineCap='round'; ctx.shadowColor='#00e676'; ctx.shadowBlur=10;
            
            let s = Math.sin(frame*0.6)*8;
            if(jumping) s = -5;

            // Corpo
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-18); ctx.stroke();
            // Pernas
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-6+s, 18); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(6-s, 18); ctx.stroke();
            // Bra√ßos
            ctx.beginPath(); ctx.moveTo(0,-15); ctx.lineTo(-10-s, -5); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,-15); ctx.lineTo(10+s, -5); ctx.stroke();
            // Cabe√ßa
            ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,-24,5,0,Math.PI*2); ctx.fill();
            ctx.restore();
        }
    };

    /**
     * ==========================================
     * üß† ENGINE (L√≥gica Central)
     * ==========================================
     */
    const Engine = {
        video: null, canvas: null, ctx: null, detector: null,
        active: false, mode: null, loopId: null,
        
        boot: async () => {
            const status = document.getElementById('boot-log');
            status.innerText = "Iniciando Hardware...";
            Sfx.init();

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} }, 
                    audio: false
                });
                
                Engine.video = document.getElementById('video-source');
                Engine.video.srcObject = stream;
                document.getElementById('webcam').srcObject = stream;
                await new Promise(r => Engine.video.onloadedmetadata = r);
                Engine.video.play(); document.getElementById('webcam').play();

                document.getElementById('screen-boot').classList.add('hidden');
                document.getElementById('screen-loading').classList.remove('hidden');

                await tf.setBackend('webgl');
                Engine.detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.MoveNet,
                    { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
                );

                Engine.canvas = document.getElementById('game-canvas');
                Engine.ctx = Engine.canvas.getContext('2d');
                
                document.getElementById('screen-loading').classList.add('hidden');
                Engine.menu();

            } catch(e) {
                status.innerText = "ERRO: " + e.message;
            }
        },

        menu: () => {
            document.getElementById('screen-menu').classList.remove('hidden');
            document.getElementById('screen-hud').classList.add('hidden');
            document.getElementById('screen-over').classList.add('hidden');
        },

        launch: (m) => {
            Engine.mode = m;
            Engine.active = true;
            document.getElementById('screen-menu').classList.add('hidden');
            document.getElementById('screen-hud').classList.remove('hidden');
            
            // Toggle UI Elements
            const wheel = document.getElementById('wheel-ui');
            const hp = document.getElementById('hp-bar-container');
            
            wheel.style.opacity = (m === 'kart') ? '1' : '0';
            if(m === 'box') hp.classList.remove('hidden'); else hp.classList.add('hidden');

            // Init Logic
            if(m==='kart') Kart.init();
            if(m==='run') Runner.init();
            if(m==='box') Box.init();
            
            Sfx.start();
            Engine.loop();
        },

        quit: () => {
            Engine.active = false;
            cancelAnimationFrame(Engine.loopId);
            Engine.menu();
        },

        loop: async () => {
            if(!Engine.active) return;

            if(Engine.canvas.width !== window.innerWidth) {
                Engine.canvas.width = window.innerWidth;
                Engine.canvas.height = window.innerHeight;
            }

            const poses = await Engine.detector.estimatePoses(Engine.video, {flipHorizontal: false});
            const pose = poses.length > 0 ? poses[0] : null;

            const ctx = Engine.ctx;
            const w = Engine.canvas.width;
            const h = Engine.canvas.height;
            let score = 0;

            if(Engine.mode==='kart') score = Kart.update(ctx, w, h, pose);
            if(Engine.mode==='run') score = Runner.update(ctx, w, h, pose);
            if(Engine.mode==='box') score = Box.update(ctx, w, h, pose);

            document.getElementById('score-val').innerText = score;
            Engine.loopId = requestAnimationFrame(Engine.loop);
        },

        gameOver: (score) => {
            Engine.active = false;
            cancelAnimationFrame(Engine.loopId);
            document.getElementById('final-score').innerText = score;
            document.getElementById('screen-hud').classList.add('hidden');
            document.getElementById('screen-over').classList.remove('hidden');
        },

        msg: (txt) => {
            const el = document.getElementById('msg-area');
            el.innerHTML = `<h1 class="text-4xl text-yellow-400 pixel-font drop-shadow-md animate-bounce">${txt}</h1>`;
            setTimeout(()=>el.innerHTML='', 1500);
        }
    };

    /**
     * ==========================================
     * üèéÔ∏è JOGO 1: PRECISION KART (Math.atan2)
     * ==========================================
     */
    const Kart = {
        pos: 0, speed: 0, playerX: 0, steer: 0, curve: 0,
        init: () => { Kart.pos=0; Kart.speed=0; Kart.playerX=0; Engine.msg("START!"); },
        update: (ctx, w, h, pose) => {
            const k = Kart;
            const cx = w/2;

            // INPUT ABSOLUTO (TRIGONOMETRIA)
            let targetAngle = 0;
            if(pose) {
                const lw = pose.keypoints.find(o=>o.name==='left_wrist');
                const rw = pose.keypoints.find(o=>o.name==='right_wrist');
                if(lw && rw && lw.score>0.3 && rw.score>0.3) {
                    // Calcula o √¢ngulo em radianos entre os dois pulsos
                    const dy = rw.y - lw.y;
                    const dx = rw.x - lw.x;
                    // Math.atan2 d√° o √¢ngulo exato. 
                    // Se a m√£o direita estiver abaixo da esquerda (dy > 0), o √¢ngulo √© positivo.
                    const angle = Math.atan2(dy, dx);
                    
                    targetAngle = angle * 1.5; // Multiplicador para sensibilidade

                    if(k.speed < 100) k.speed += 1;
                } else {
                    k.speed *= 0.95; // Freia se soltar volante
                }
            }
            
            // Suaviza√ß√£o leve para n√£o tremer
            k.steer += (targetAngle - k.steer) * 0.2;

            // Visual do Volante na UI
            document.getElementById('wheel-indicator').style.transform = `translateY(-50%) rotate(${k.steer * 57.2958}deg)`; // Rad to Deg

            // F√çSICA
            k.pos += k.speed * 0.01;
            k.curve = Math.sin(k.pos * 0.5) * 2;
            
            k.playerX += k.steer * (k.speed/400); // Carro vira
            k.playerX -= k.curve * (k.speed/800); // For√ßa centrifuga

            if(Math.abs(k.playerX) > 1.3) { k.speed *= 0.9; } // Grama

            // DESENHO
            Gfx.drawRoad(ctx, w, h, k.pos, k.curve);
            const carScreenX = cx + (k.playerX * w * 0.25);
            Gfx.drawKart(ctx, carScreenX, h-80, k.steer);

            return Math.floor(k.pos * 10);
        }
    };

    /**
     * ==========================================
     * üèÉ JOGO 2: STREET RUNNER (Inverted Lanes)
     * ==========================================
     */
    const Runner = {
        lane: 0, score: 0, frame: 0, obstacles: [], noseBase: 0, jumping: false, jumpH: 0,
        init: () => { Runner.score=0; Runner.obstacles=[]; Runner.noseBase=0; Engine.msg("CORRA!"); },
        update: (ctx, w, h, pose) => {
            const r = Runner;
            const cx = w/2;
            r.frame++;

            // INPUT CORRIGIDO (ESPELHO)
            if(pose) {
                const nose = pose.keypoints.find(o=>o.name==='nose');
                if(nose && nose.score > 0.4) {
                    // L√ìGICA DE ESPELHO INVERTIDA
                    // Raw Video: 0 (Esq) ... 640 (Dir)
                    // Se Nariz < 250 (Esq da camera) -> O usu√°rio foi para SUA DIREITA f√≠sica.
                    // Lane 1 = Direita.
                    if(nose.x < 250) r.lane = 1; 
                    else if(nose.x > 390) r.lane = -1; // Esquerda f√≠sica
                    else r.lane = 0;

                    // PULO
                    if(r.noseBase === 0) r.noseBase = nose.y;
                    if(nose.y < r.noseBase - 35 && !r.jumping) {
                        r.jumping = true; r.jumpH = 22; Sfx.jump();
                    }
                    r.noseBase = (r.noseBase * 0.95) + (nose.y * 0.05);
                }
            }

            if(r.jumping) {
                r.jumpH -= 1.5;
                if(r.jumpH < -22) r.jumping = false;
            }

            // SPAWN
            if(r.frame % 50 === 0) r.obstacles.push({l: Math.floor(Math.random()*3)-1, z: 1000});

            // RENDER
            ctx.clearRect(0,0,w,h);
            ctx.fillStyle = '#0d0d0d'; ctx.fillRect(0,0,w,h);
            
            // Grid 3D
            ctx.strokeStyle='#00e676'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(cx-150, h/2); ctx.lineTo(0, h); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx+150, h/2); ctx.lineTo(w, h); ctx.stroke();

            // OBST√ÅCULOS
            r.obstacles.forEach((o, i) => {
                o.z -= 20; 
                if(o.z < -100) { r.obstacles.splice(i,1); r.score+=10; Sfx.coin(); }
                
                const scale = 500/(o.z+100);
                if(scale > 0) {
                    const ox = cx + (o.l * 200 * scale);
                    const oy = h/2 + (50 * scale);
                    const sz = 70 * scale;

                    ctx.fillStyle = '#ff3d00';
                    ctx.fillRect(ox-sz/2, oy, sz, sz);

                    // Colis√£o (Ignora se pulando)
                    const jumpHeight = Math.max(0, (22*22 - r.jumpH*r.jumpH)); // Par√°bola simples
                    if(o.z < 50 && o.z > -50 && o.l === r.lane && !r.jumping) {
                        Engine.gameOver(r.score);
                    }
                }
            });

            // PLAYER
            const px = cx + (r.lane * 150);
            const py = h - 100 - (r.jumping ? 80 : 0);
            Gfx.drawRunner(ctx, px, py, r.frame, r.jumping);

            return r.score;
        }
    };

    /**
     * ==========================================
     * ü•ä JOGO 3: BOXE (Skeleton Stickman)
     * ==========================================
     */
    const Box = {
        hp: 100, score: 0, hitFrame: 0, targets: [], lastSpawn: 0,
        init: () => { Box.hp=100; Box.score=0; Engine.msg("FIGHT!"); },
        update: (ctx, w, h, pose) => {
            const b = Box;
            const now = Date.now();
            ctx.clearRect(0,0,w,h);

            // 1. DESENHAR ESQUELETO COMPLETO
            Gfx.drawFullSkeleton(ctx, pose, w, h);

            // 2. INPUT M√ÉOS
            let punches = [];
            if(pose) {
                const mapX = x => w - (x/640 * w); // Mirror X
                const mapY = y => y/480 * h;
                const kp = pose.keypoints;
                const lw = kp.find(k=>k.name==='left_wrist');
                const rw = kp.find(k=>k.name==='right_wrist');

                if(lw && lw.score>0.3) punches.push({x: mapX(lw.x), y: mapY(lw.y)});
                if(rw && rw.score>0.3) punches.push({x: mapX(rw.x), y: mapY(rw.y)});
            }

            // 3. TARGETS
            if(now - b.lastSpawn > 900) {
                b.targets.push({x: Math.random()*(w-100)+50, y: Math.random()*(h/2)+50, r: 45, s: now});
                b.lastSpawn = now;
            }

            b.targets.forEach((t, i) => {
                const age = (now - t.s)/1500;
                if(age>1) { b.targets.splice(i,1); return; }

                ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                ctx.fillStyle = `rgba(255,255,0,${1-age})`; ctx.fill();
                ctx.strokeStyle='#fff'; ctx.stroke();

                punches.forEach(p => {
                    if(Math.hypot(p.x-t.x, p.y-t.y) < t.r + 20) {
                        b.targets.splice(i,1);
                        b.score += 100;
                        b.hp = Math.max(0, b.hp - 5);
                        Sfx.hit();
                    }
                });
            });

            document.getElementById('hp-bar').style.width = b.hp + '%';
            if(b.hp <= 0) { b.hp = 100; b.score += 500; Engine.msg("K.O.!"); }

            return b.score;
        }
    };
</script>
</body>
</html>
